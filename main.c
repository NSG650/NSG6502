#include "nsg6502.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void dump_hex(const void *data, size_t size) {
	char ascii[17];
	size_t i, j;
	ascii[16] = '\0';
	for (i = 0; i < size; ++i) {
		printf("%02X ", ((unsigned char *)data)[i]);
		if (((unsigned char *)data)[i] >= ' ' &&
			((unsigned char *)data)[i] <= '~') {
			ascii[i % 16] = ((unsigned char *)data)[i];
		} else {
			ascii[i % 16] = '.';
		}
		if ((i + 1) % 8 == 0 || i + 1 == size) {
			printf(" ");
			if ((i + 1) % 16 == 0) {
				printf("|  %s \n", ascii);
			} else if (i + 1 == size) {
				ascii[(i + 1) % 16] = '\0';
				if ((i + 1) % 16 <= 8) {
					printf(" ");
				}
				for (j = (i + 1) % 16; j < 16; ++j) {
					printf("   ");
				}
				printf("|  %s \n", ascii);
			}
		}
	}
}

void main_memory_write_callback(struct nsg6502_cpu *c, uint16_t addr,
								uint8_t data) {
#ifdef NSG6502_DEBUG
	printf("NSG6502: Writing 0x%hhx to 0x%hx\n", data, addr);
#endif
	if (addr == 0x200) {
		printf("%c", data);
		if (data == '\r') {
			printf("\n");
		}
	}
	c->memory[addr] = data;
}

uint8_t main_memory_read_callback(struct nsg6502_cpu *c, uint16_t addr) {
#ifdef NSG6502_DEBUG
	printf("NSG6502: Reading 0x%hx\n", addr);
#endif
	if (addr == 0xFE) {
		return rand() % 256;
	} else if (addr == 0x0202) {
		return 1;
	} else if (addr == 0x201) {
		uint8_t k = 0;
		read(STDIN_FILENO, &k, 1);
		if (k == '\n') {
			return '\r';
		}
		return k;
	} else {
		return c->memory[addr];
	}
}

int main(void) {
	struct nsg6502_cpu cpu = {0};
	cpu.memory = malloc(0xFFFF + 1);

	cpu.memory_write_callback = main_memory_write_callback;
	cpu.memory_read_callback = main_memory_read_callback;

	srand(cpu.memory[0x42]);

	unsigned char wozmon[] = {
		0xd8, 0x58, 0xa9, 0x1b, 0xc9, 0x08, 0xf0, 0x13, 0xc9, 0x1b, 0xf0, 0x03,
		0xc8, 0x10, 0x0f, 0xa9, 0x5c, 0x20, 0xe7, 0xff, 0xa9, 0x0d, 0x20, 0xe7,
		0xff, 0xa0, 0x01, 0x88, 0x30, 0xf6, 0xad, 0x02, 0x02, 0xc9, 0x01, 0xd0,
		0xf9, 0xad, 0x01, 0x02, 0x99, 0x00, 0x03, 0x20, 0xe7, 0xff, 0xc9, 0x0d,
		0xd0, 0xd2, 0xa0, 0xff, 0xa9, 0x00, 0xaa, 0x0a, 0x0a, 0x85, 0x2b, 0xc8,
		0xb9, 0x00, 0x03, 0xc9, 0x0d, 0xf0, 0xd1, 0xc9, 0x2e, 0x90, 0xf4, 0xf0,
		0xee, 0xc9, 0x3a, 0xf0, 0xeb, 0xc9, 0x52, 0xf0, 0x3b, 0x86, 0x28, 0x86,
		0x29, 0x84, 0x2a, 0xb9, 0x00, 0x03, 0x49, 0x30, 0xc9, 0x0a, 0x90, 0x06,
		0x69, 0x88, 0xc9, 0xfa, 0x90, 0x11, 0x0a, 0x0a, 0x0a, 0x0a, 0xa2, 0x04,
		0x0a, 0x26, 0x28, 0x26, 0x29, 0xca, 0xd0, 0xf8, 0xc8, 0xd0, 0xe0, 0xc4,
		0x2a, 0xf0, 0x94, 0x24, 0x2b, 0x50, 0x10, 0xa5, 0x28, 0x81, 0x26, 0xe6,
		0x26, 0xd0, 0xb5, 0xe6, 0x27, 0x4c, 0x3c, 0xff, 0x6c, 0x24, 0x00, 0x30,
		0x2b, 0xa2, 0x02, 0xb5, 0x27, 0x95, 0x25, 0x95, 0x23, 0xca, 0xd0, 0xf7,
		0xd0, 0x14, 0xa9, 0x0d, 0x20, 0xe7, 0xff, 0xa5, 0x25, 0x20, 0xd4, 0xff,
		0xa5, 0x24, 0x20, 0xd4, 0xff, 0xa9, 0x3a, 0x20, 0xe7, 0xff, 0xa9, 0x20,
		0x20, 0xe7, 0xff, 0xa1, 0x24, 0x20, 0xd4, 0xff, 0x86, 0x2b, 0xa5, 0x24,
		0xc5, 0x28, 0xa5, 0x25, 0xe5, 0x29, 0xb0, 0xc1, 0xe6, 0x24, 0xd0, 0x02,
		0xe6, 0x25, 0xa5, 0x24, 0x29, 0x07, 0x10, 0xc8, 0x48, 0x4a, 0x4a, 0x4a,
		0x4a, 0x20, 0xdd, 0xff, 0x68, 0x29, 0x0f, 0x09, 0x30, 0xc9, 0x3a, 0x90,
		0x02, 0x69, 0x06, 0x8d, 0x00, 0x02, 0x60};
	unsigned int wozmon_len = 235;

	// char code[] = "\xad\x01\x02\x8d\x00\x02\x4c\x00\x06";
	memcpy(&cpu.memory[0xFF00], wozmon, wozmon_len);
	cpu.memory[0xFFFC] = 0x00;
	cpu.memory[0xFFFD] = 0xFF;

	nsg6502_reset(&cpu);

	while (cpu.pc != 0x0600 + sizeof(wozmon) - 1) {
		nsg6502_opcode_execute(&cpu);
	}

	free(cpu.memory);
	return 0;
}
